Домашнее задание к занятию "3.3. Операционные системы, лекция 1"
********************************************************************************

1. Какой системный вызов делает команда cd? В прошлом ДЗ мы выяснили, что cd
не является самостоятельной программой, это shell builtin, поэтому запустить
strace непосредственно на cd не получится. Тем не менее, вы можете запустить
strace на /bin/bash -c 'cd /tmp'. В этом случае вы увидите полный список
системных вызовов, которые делает сам bash при старте. Вам нужно найти тот
единственный, который относится именно к cd.

Скрин - 01_01.png
********************************************************************************

2. Попробуйте использовать команду file на объекты разных типов на файловой
системе. Например:
vagrant@netology1:~$ file /dev/tty
/dev/tty: character special (5/0)
vagrant@netology1:~$ file /dev/sda
/dev/sda: block special (8/0)
vagrant@netology1:~$ file /bin/bash
/bin/bash: ELF 64-bit LSB shared object, x86-64
Используя strace выясните, где находится база данных file на основании которой
она делает свои догадки.

Команда file использует для работы файл /usr/share/misc/magic.mgc
openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3

Скрин - 02_01.png
********************************************************************************

3. Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удален
(deleted в lsof), однако возможности сигналом сказать приложению переоткрыть
файлы или просто перезапустить приложение - нет. Так как приложение продолжает
писать в удаленный файл, место на диске постепенно заканчивается. Основываясь на
знаниях о перенаправлении потоков предложите способ обнуления открытого
удаленного файла (чтобы освободить место на файловой системе).

Ищем удалённый файл
lsof | grep '(deleted)'
или
lsof -nP | grep '(deleted)'
или
lsof +L1 (lsof -nP +L1)

Ищем соответствующие PID и FD
/proc/<pid>/fd/

Например PID - 2137, FD - 1

Обнуляем (cat /dev/null в FD):
cat /dev/null > /proc/2137/fd/1

********************************************************************************

4. Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)?

Зомби не занимают памяти, но присутствует в списке процессов.
Но блокируют записи в таблице процессов, размер которой ограничен для каждого
пользователя и системы в целом.
********************************************************************************

5. В iovisor BCC есть утилита opensnoop:

root@vagrant:~# dpkg -L bpfcc-tools | grep sbin/opensnoop
/usr/sbin/opensnoop-bpfcc
На какие файлы вы увидели вызовы группы open за первую секунду работы утилиты?
Воспользуйтесь пакетом bpfcc-tools для Ubuntu 20.04. Дополнительные сведения по
установке (https://github.com/iovisor/bcc/blob/master/INSTALL.md).

vagrant@vagrant:~$ sudo opensnoop-bpfcc
PID    COMM               FD ERR PATH
604    irqbalance          6   0 /proc/interrupts
604    irqbalance          6   0 /proc/stat
604    irqbalance          6   0 /proc/irq/20/smp_affinity
604    irqbalance          6   0 /proc/irq/0/smp_affinity
604    irqbalance          6   0 /proc/irq/1/smp_affinity
604    irqbalance          6   0 /proc/irq/8/smp_affinity
604    irqbalance          6   0 /proc/irq/12/smp_affinity
604    irqbalance          6   0 /proc/irq/14/smp_affinity
604    irqbalance          6   0 /proc/irq/15/smp_affinity
604    irqbalance          6   0 /proc/interrupts
604    irqbalance          6   0 /proc/stat
604    irqbalance          6   0 /proc/irq/20/smp_affinity
604    irqbalance          6   0 /proc/irq/0/smp_affinity
604    irqbalance          6   0 /proc/irq/1/smp_affinity
604    irqbalance          6   0 /proc/irq/8/smp_affinity
604    irqbalance          6   0 /proc/irq/12/smp_affinity
604    irqbalance          6   0 /proc/irq/14/smp_affinity
604    irqbalance          6   0 /proc/irq/15/smp_affinity
1      systemd            12   0 /proc/617/cgroup
1      systemd            12   0 /proc/31572/cgroup
1      systemd            12   0 /proc/25923/cgroup
604    irqbalance          6   0 /proc/interrupts
604    irqbalance          6   0 /proc/stat
604    irqbalance          6   0 /proc/irq/20/smp_affinity
604    irqbalance          6   0 /proc/irq/0/smp_affinity
604    irqbalance          6   0 /proc/irq/1/smp_affinity
604    irqbalance          6   0 /proc/irq/8/smp_affinity
604    irqbalance          6   0 /proc/irq/12/smp_affinity
604    irqbalance          6   0 /proc/irq/14/smp_affinity
604    irqbalance          6   0 /proc/irq/15/smp_affinity

********************************************************************************

6. Какой системный вызов использует uname -a? Приведите цитату из man по этому
системному вызову, где описывается альтернативное местоположение в /proc, где
можно узнать версию ядра и релиз ОС.

Какой системный вызов использует uname -a?
Скрин - 06_01.png

Цитата из man uname(2):
Part of the utsname information is also accessible via
/proc/sys/kernel/{ostype, hostname, osrelease, version,
domainname}.

cat /proc/version
Вывод:
Linux version 4.8.0-53-generic (buildd@lgw01-56) (gcc version 5.4.0 20160609
(Ubuntu 5.4.0-6ubuntu1~16.04.4) ) #56~16.04.1-Ubuntu SMP Tue May 16 01:18:56
UTC 2017

Команда показывает текущую версию ядра, под которым работает операционная
система. Вывод команды включает в себя содержимое файлов:
/proc/sys/kernel/ostype, /proc/sys/kernel/osrelease, и /proc/sys/kernel/version.
Фактический, можно получить похожий результат используя команду:

cat /proc/sys/kernel/{ostype,osrelease,version}

Получим:

Linux
4.8.0-53-generic
#56~16.04.1-Ubuntu SMP Tue May 16 01:18:56 UTC 2017
********************************************************************************

7. Чем отличается последовательность команд через ; и через && в bash?
Например:
root@netology1:~# test -d /tmp/some_dir; echo Hi
Hi
root@netology1:~# test -d /tmp/some_dir && echo Hi
root@netology1:~#
Есть ли смысл использовать в bash &&, если применить set -e?

Оператор ; - несколько команд в одной строке, выполняются последовательно,
одна за другой.
command1 ; command2
оболочка запустит на выполнение команду command1, дождется, пока ее выполнение
завершится, далее запустит command2, дождется ее завершения, после чего снова
выведет приглашение командной строки, ожидая действий пользователя.
Не важно чем закончится выполнение command1.

Операторы && - управляющий оператор
command1 && command2
command2 выполняется только в том случае, если статус выхода из команды command1
равен нулю, что говорит об успешном ее завершении.

set -e останавливает выполнение скрипта, если команда имеет ошибку, что
противоположно поведению по умолчанию shell, которое заключается в игнорировании
ошибок в скриптах.
-е опция для немедленного выхода, если выходное состояние команды ненулевое.
Если command1 && command2 возвращается ненулевое значение, то оно игнорируется
set -e.

Смысл использовать && есть. set -e был попыткой добавить в оболочку
«автоматическое обнаружение ошибок».
Единственная информация, передаваемая оболочке внешней программой, - это статус
выхода - по соглашению 0 для успеха и ненулевое значение для «какой-то ошибки».
Разработчики исходной оболочки Bourne решили, что они создадут функцию, которая
позволит оболочке проверять статус выхода каждой выполняемой команды и прерывать
выполнение, если одна из них возвращает ненулевое значение. Так родился set -e .
Но многие команды возвращают ненулевое значение, даже если ошибки не было.
http://mywiki.wooledge.org/BashFAQ/105
********************************************************************************

8. Из каких опций состоит режим bash set -euxo pipefail и почему его хорошо было
бы использовать в сценариях?

Иногда хорошо использовать в скриптах для анализа ошибок.
-e Прервёт выполнение скрипта при обнаружении ошибки (команда имеет ненулевой
статус)
-u Влияет на переменные. заставляет оболочку bash обрабатывать неустановленные
переменные как ошибку и немедленно завершать работу.
-x Заставляет bash печатать каждую команду перед ее выполнением. Это может
оказаться большим подспорьем, когда вам нужно попытаться отладить сбой сценария
bash через его журналы.
-o pipefail Если pipefail включен, статус возврата конвейера - это значение
последней (самой правой) команды для выхода с ненулевой статус или ноль, если
все команды завершаются успешно.
********************************************************************************

9. Используя -o stat для ps, определите, какой наиболее часто встречающийся
статус у процессов в системе. В man ps ознакомьтесь (/PROCESS STATE CODES) что
значат дополнительные к основной заглавной буквы статуса процессов. Его можно не
учитывать при расчете (считать S, Ss или Ssl равнозначными).

Наиболее часто встречающийся статус - S (Ss) и R (R+).
Скрин - 09_01.png

s - является лидером сеанса (сессии)
+ находится в группе процессов переднего плана
l является многопоточным (с использованием CLONE_THREAD, как NPTL pthreads)
< высокий приоритет
t остановлен отладчиком во время трассировки

Скрин - 09_02.png
********************************************************************************
